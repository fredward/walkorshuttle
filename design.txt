	We set out to create a transit-optimization web app that can deliver real-time estimates involving Harvard's shuttle system. We incorporated Bing Maps walking estimates with shuttle tracking data from Transloc in order to deliver an accurate picture of the best way to move around Harvard.
	Our project has been deployed as a location-aware web-app, letting anyone with a computer or non-obsolete smart phone easily access all the features of our site. Our app is written under the Django framework, a web app development system for Python. We chose Django because it makes handling data extremely simple. Every piece of data can be treated as an object, and Django handles all the backend database querying for you. The core of our project was two external APIs: Transloc and Bing Maps. Transloc's shuttle data provided real-time data on Harvard shuttle routes, stops, vehicles, and arrival estimates. We constructed multiple, interrelated models to hold and manipulate Transloc's data. In order to keep our database as current as possible, we wrote multiple scripts that update our database with vehicle data every second and route data every 30 seconds. These are compiled into a single, looping bash script that runs in the background, keeping our Django database constantly updated. We did run into a minor race condition as a result of this constant updating, but forcing manual transaction committing solved that. 
	We chose to use Bing Maps for our walking data because it allowed far more queries per month than Google's API and was far less restrictive in it's use. After acquiring the user's location and the location of all of the currently active stops, we compute the walking time between each of those stops. While this query is a little slow, we only have to do it once when we start our server. 
	Once our models are established and being updated, our main (and only) page is presented to the user. Because our app relies on many variable and often lengthy queries, any and all view updating is done asynchronously with ajax. Initially, a bare template is presented to the user, but those blanks are filled in quickly as the browser returns geolocation data. The user is presented with the nearest shuttle stop to them, and a list of when the next shuttles will arrive at that stop. Clicking each shuttle display drops down a list of the next three stops that the vehicle will make. We decided that most users would want basic shuttle-tracking functionality first, so it is at the top of the application. Data is requested from Django views, which query our models and respond with json objects. We present the shuttle data as soon as it is available using JQuery for DOM traversal. There is a small amount of session specific data relating to the users location that we must store, and Django makes it easy with its database-backed sessions. 
	The defining feature of our app is the ability to present the user with a list of destinations, and, upon selection, the app will present some computed data about the routes. As of now, we display the time to walk to the destination, the route with the least walking time, the route with the least time in transit, and the fastest real-time route. The shuttles travel unusual routes with interesting schedules, so some of these outputs are a little surprising. We try to present 4 pieces of data, so that if one calculation goes awry the user still has plenty of useful shuttle information. All of this data is presented after posting the user's choice to a Django view, which returns a JSON response object that will be immediately rendered for the user. 
	Django provides a simple and easy framework for taking requests, querying the models for data, calculating and preparing the response, and sending the response for rendering by Javascript. We rely heavily on data whose immediate availability is not certain. Relying on only a single template that is updated in real time allows us to be flexible with the temporal aspects of our site. Never is the user left staring at a white page as next template stalls in its rendering. This asynchronicity allows us to cheat slightly to gain some performance. As soon as the user is geolocated, we query Bing for walking times to every possible stop. By the time the user selects their single destination stop, we have almost certainly received the results of that query, and can nearly instantly display our route calculations. This saves a 1-3 second lag if we were to wait to query Bing. We do place extra load on Bing's servers, but it is likely inconsequential, as we are well under their monthly quota for requests. Perhaps the most unusual problem we faced was the caching of post request on mobile devices. Mobile phones seemed to cache post data far more aggressively than other platforms, and none of the built-in Django caching management could fix it. Eventually, we just added a random string to the end of the offending post request's url each time it was sent. Thanks to Django's excellent url configuration, the urls were still resolved to the same view function, but caching was prevented because the browser no longer recognized the urls as identical.
	We have deployed our app on Heroku, which allows us to easily run our server and the database updating script at once. We only have 750 free process-hours, but that should be more than enough for now. In addition, site management on Heroku is performed via git, which is already our standard for source control, making deployment even simpler.
	While our app may not be very pretty, we are happy with the wealth of data was have synthesized together into a manageable display and its decently speedy performance. This was our first attempt at any sort of internet programming project, and I think we are both happy with the results!